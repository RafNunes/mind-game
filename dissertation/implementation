One of the first implementation decisions to be made was in how to keep track of the pieces in play. When generating the possible moves from a given position, it is useful to have a list of the pieces for the player whose turn it is so that they can be iterated through, generating the moves for each one in turn, without having to search over the whole board to find each piece. However, it is often necessary to access the piece, if any, at a given position on the board. It would be very inefficient to search through each player’s lists of pieces to see if any are occupying the position in question. Thus it is necessary for squares in the board data structure to contain information about the piece that occupies it. Once again, it would be very inefficient to have to search for the corresponding piece in one of the lists to ensure that a given update on the board is reflected appropriately in the list. The solution we found was to keep doubly linked lists of each player’s pieces and to have each position on the board point to nodes in these lists. This way, if a piece is accessed by querying the board, it can be found in constant time in the list and updated appropriately if it needs to be moved or captured.

The Board class supports making and undoing moves by maintaining a stack of previous moves, each of which contains the information required to revert the state of the game to what it was before the move was played. For example, the Move class contains a ‘firstTimeMoving’ field which is set to ‘true’ if the corresponding piece’s ‘hasMoved’ field was set to ‘false’ before the move was made. Thus, when such a move is undone, the corresponding piece can have its ‘hasMoved’ field set back to ‘false’, which is important for rooks and kings which are able to return to their starting positions after having moved. Similarly, the Move class stores any capture associated with the move so that a captured piece can be returned to the board upon undoing that move. This allows the evaluator to freely search the tree of possible positions originating from the current position, making and undoing moves without risking loosing the actual state of the game and without generating a new copy of the board for each position explored.

The AI uses a standard min-max search with alpha-beta pruning, quiescence and one step of iterative deepening. It is made to be easily configurable, with many parameters settable within the constructor. For example, it is possible to set a ‘gauging’ depth as well as a full depth. We found that it was significantly quicker to first perform a shallower search and order the moves based on their estimated values at this depth before performing a full depth search, instead of just performing the full depth search straight away. This is because it gives alpha-beta pruning a higher chance of finding better moves earlier and thus being able to discard other branches from the search without fully exploring them. For the same reason, we also order the possible moves at each node of the tree before searching them based simply on the value of any capture that each move involves.

The evaluation function itself required substantial research being as it is very specific to the subtleties of chess strategy, an area that none of the team had much experience in. As well as obvious things such as material value and number of available moves our evaluator considers several other factors. Central control was found to be important. The centre offers the quickest route of travel between dislocated areas of the board for most pieces. Thus it is essential to control the centre by having pieces both occupying and attacking central squares. Our evaluator awards different values for attacking and occupying both inner central (middle 4) and outer central (surrounding 12) squares.

Another factor was king safety. During the early/middle game, our evaluator rewards having the king tucked away in a corner. Bonuses are assigned for having the king on the back row near one of the sides with no pieces in between it and the side. Bonuses are also assigned for having pawns in one of the two rows in front of the king on its column or the two adjacent columns. Such pawns act as a shield, preventing enemy pieces from attacking the king. Bonuses and penalties are also applied based on friendly or enemy pieces attacking squares around the king. During the end game, on the contrary, the king is rewarded for being closer to the centre and thus able to quickly reach any location on the board. In the end game, when there is little material on the board, it makes little difference to the safety of the king where it is, and the main factor becomes its utility as a threat to enemy pieces.

Finally, pawn structure was found to have many facets, the following of which were accounted for by our evaluator. Side pawns are those on either of the two side-most columns. They are considered to be weaker because they can only attack in one direction. Doubled pawns are two pawns of the same colour on the same column. They are also considered weaker because they cannot defend each other and one blocks the progress of the other. Isolated pawns are pawns with no friendly pawns on either of their adjacent columns. They are considered weaker because they cannot offer protection to nor be protected by any other pawns without pawns migrating to different columns. Passed pawns are those with no enemy pawns between it and the back row on the same column as it or on either of the two adjacent columns. Passed pawns are rewarded a bonus because they are much more likely to be able to reach the back row and be promoted, or at lease to cause the enemy a lot more hassle in preventing the pawn from being promoted then if they had a pawn of their own which could halt its progress.

Evaluating pawn structure was one of the more performance sensitive parts of the evaluator. It was important not to repeatedly search through each of the adjacent columns to each pawn for friendly or enemy pawns in order to assess the aforementioned factors related to pawn structure. Instead, we first make a pass over both players’ lists of pieces, looking for pawns and updating, for each column, each player’s most and least advanced pawns. During this first pass, we also keep count of how many doubled pawns each player has. With this information we can efficiently search for isolated and passed pawns. We simply take in turn, the information that we gathered for each column. If, for example, there is a white pawn in a given column, we check in constant time whether there are any white pawns in the adjacent columns. We also check if the most advanced white pawn in that column is closer to the back row than the least advanced black pawn. Once again, this is done in constant time.
